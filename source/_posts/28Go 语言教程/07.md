---
title: 七、Go 语言变量
abbrlink: 4615d76a
categories: 
tags: 
date: 
updated: 
top_img: https://www.bing.com/th?id=OHR.KarstMountains_FR-FR0753680541_UHD.jpg
cover: https://www.bing.com/th?id=OHR.Knobbelzwaan_FR-FR0893259980_UHD.jpg
keywords: 
---
# 七、Go 语言变量

变量是程序可操作的存储区的名称。Go 语言中 中每个变量都有特定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中

Go 语言中的**变量名**是标准的标识符，由字母、数字、下划线组成，不能以数字开头

## 变量声明

**var** 关键字用来声明变量

```go
var identifier type
```

声明变量时可以指定变量类型，声明后若不赋值，Go 语言会使用默认值

```go
var v_name v_type
v_name = value
```

声明变量时同时初始化，则可以省去变量类型， Go 编译器会根据值自行判定变量类型

```go
var v_name = value
```

声明变量时还可以省去 **var** 关键字，但要同时初始化，语法如下

```go
v_name := value
```

注意 `:=` 左侧的变量不能是已经声明过的，否则会导致编译错误

例如

```go
var a int = 10
var b = 10
c : = 10
```

### 范例

```go
package main

var a = "技术"
var b string = "com"
var c bool

func main(){
    println(a, b, c)
}
```

编译运行以上 Go 语言范例，输出结果如下

```
$ go run main.go
技术 com false
```

### 多变量声明

可以用逗号(,) 将类型相同的变量放在一起声明

```go
var vname1, vname2, vname3 type
```

Go 语言支持多个变量同时赋值

```go
vname1, vname2, vname3 = v1, v2, v3
```

多变量声明同时初始化

```go
var vname1, vname2, vname3 = v1, v2, v3
```

和 Python 很像,不需要显示声明类型，自动推断

类型推导方式的多变量声明，这种声明只能用于函数内部

```go
vname1, vname2, vname3 := v1, v2, v3
```

注意，出现在 `:=` 左侧的变量不能是已经被声明过的，否则会导致编译错误

还可以用小括号来声明多个变量，但这种因式分解关键字的写法一般用于声明全局变量

```go
var (
    vname1 v_type1
    vname2 v_type2
)
```

### 范例

```go
package main

var x, y int
var (  // 这种因式分解关键字的写法一般用于声明全局变量
    a int
    b bool
)

var c, d int = 1, 2
var e, f = 123, "hello"

//这种不带声明格式的只能在函数体中出现
//g, h := 123, "hello"

func main(){
    g, h := 123, "hello"
    println(x, y, a, b, c, d, e, f, g, h)
}
```

编译运行以上 Go 语言范例，输出结果如下

```
0 0 0 false 1 2 123 hello 123 hello
```

## 值类型和引用类型

Go 语言中的变量类型分为值类型和引用类型

### 1. 值类型

值类型的变量直接指向存在内存中的值, 值类型的变量的值存储在栈中

Go 语言中，int、float、bool 和 string 这些基本类型都属于值类型

当使用赋值符号 `=` 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 i 的值进行了拷贝：

我们可以通过输出 `&i` 和 `&j` 看到它们的内存地址 例如：&i= 0xf881500048（每次的地址都可能不一样）

内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同

### 2. 引用类型

一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字节(byte) 所在的位置，这个内存地址为称之为指针，这个指针实际上也被存在另外的某一个 int 类型变量中

同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；

也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址

当使用赋值语句 r2 = r1 时，只有引用（地址）被复制

如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响

Go 更复杂的数据通常会需要使用一段连续的内存，这些数据一般使用引用类型保存

## 简短形式，使用 := 赋值操作符

Go 语言支持类型自动推导，所以在变量的初始化时省略变量的类型而由系统自动推断

此时变量声明语句写上 var 关键字其实是显得有些多余了，因此我们可以将它们简写为

```go
a := 50
b := false
```

a 和 b 的类型（int 和 bool）将由编译器自动推断

这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值

使用操作符 `:=` 可以高效地创建一个新的变量，称之为初始化声明

### 注意事项

1、 在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明

```
例如：`a := 20` 就是不被允许的，编译器会提示错误
    no new variables on left side of :=
但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值
```

2、 如果我们在定义变量 a 之前使用它，则会得到编译错误 undefined: a
3、 如果声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误

例如下面这个例子当中的变量 a：

```GO
    package main

    import "fmt"

    func main() {
      var a string = "abc"
      fmt.Println("hello, world")
          }
```

尝试编译以上 Go 语言范例，会得到如下错误

```
 $ go run main.go
# command-line-arguments
    ./main.go:6:6: a declared and not used
```

提示变量 a 定义了却没有使用，所以  `fmt.println("hello, world", a)`会移除错误

4、 全局变量是允许声明但不使用

例如下面这个例子当中的变量 a：

```GO
  package main

    import "fmt"

    var a string = "abc"

    func main() {

       fmt.Println("hello, world")
    }
```

我们编译运行这段代码，输出结果如下

```
   $ go run main.go
    hello, world
```



## 并行赋值

#### 同一类型的多个变量可以声明在同一行，这被称为**并行**或**同时**赋值

例如：

```go
var a, b, c int
```

#### 多变量可以在同一行进行赋值

例如：

```GO
a, b, c = 5, 7, "abc"
```

上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用：

```GO
a, b, c := 5, 7, "abc"
```

右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 “abc”

并行赋值也被用于当一个函数返回多个返回值时

比如下面的 val 和错误 err 是通过调用 Func1 函数同时得到：

```GO
val, err = Func1(var1)
```

### 并行赋值的妙用

如果想要交换两个变量的值，则可以简单地使用 a, b = b, a

## 特殊变量 – 下划线 ( _ )

空白标识符 `_` 也被用于抛弃值，如值 5 在：`_, b = 5, 7` 中被抛弃

`_` 实际上是一个只写变量，我们不能得到它的值

这样做是因为 Go 语言中你必须使用所有被声明的变量， 但有时并不需要使用从一个函数得到的所有返回值